function savestruct = save_data(filepath, keywords, source, datafile, inputfile, leaveflag, deletecurrent, addallsubfolders)
%SAVE_DATA Saves the data generated by 'TS_compute' into a file.
%   It must be run within a folder containing:
%       - A file of hctsa data (default: hctsa.mat)
%       - A file containing the parameters used to generate the data
%       (default: inputs.mat)
%   
%   'filepath' is the location in which the data will be saved (including
%   the file name and extension!). If no such file is present, one will be created
%
%   'keywords' is a comma delimited string containing keywords for the time
%   series data, with no white space
%
%   'source' is a string containing the function, original location or the
%   method used to collect the time series
%
%   (optional) 'datafile' is a string naming the file containing hctsa data (default:
%   HCTSA.mat)
%
%   (optional) 'inputfile' is a string naming the file containing parameter data (default:
%   inputs.mat)
%
%   (optional) 'leaveflag' is a logical determining whether a flag is
%   left in the current folder to show it has already been added, and to
%   give the index in time_series_data of the current folder.
%
%   (optional) 'deletecurrent' is a logical specifying whether the
%   existing data file is to be deleted (default: false)
%
%   (optional) 'addallsubfolders' is a logical; if true, all
%   subdirectories in the current directory will be searched and their
%   contents saved.

    %% Checking inputs
    tic
    if nargin < 4 || isempty(datafile)
        datafile = 'HCTSA.mat';
    end
    if nargin < 5 || isempty(inputfile)
        inputfile = 'inputs.mat';
    end
    if nargin < 6 || isempty(leaveflag)
        leaveflag = true;
    end
    if nargin < 7 || isempty(deletecurrent)
        deletecurrent = false;
    end
    if nargin < 8 || isempty(addallsubfolders)
        addallsubfolders = 0;
    end
    
    
    %find_folder = which('save_data.m');
    %filepath = [find_folder(1:end-length('save_data.m')), filename];
    if ~isempty(filepath)
        filepath = fullfile(filepath);
        if deletecurrent && exist(filepath, 'file')
            delete(filepath)
        end
    end
    if nargin < 3 || isempty(source)
        source = 'Unknown';
    end
    
    %% Get subfolders  
    homedir = pwd;
    paths = regexp(genpath(homedir),['[^', pathsep, ']*'],'match');
    paths = paths(~contains(paths, [filesep, '.']));
    if addallsubfolders
        paths = paths(~strcmp(paths, homedir)); % Remove the current folder
        if isempty(paths)
            error('This folder contains no subfolders')
        end
    else
        paths = paths(strcmp(paths, homedir)); % Keep only the current folder
    end
   
    
    savestructcell = cell(length(paths), 1);
    
    for pathind = 1:length(paths)
        if ~exist(fullfile(paths{pathind}, datafile), 'file') || ~exist(fullfile(paths{pathind}, inputfile), 'file')
            if ~addallsubfolders
                error('One or more of the required files is missing')
            elseif addallsubfolders
                warning('This folder does not contain the required files. Skipping.')
                continue
            end
        end
        if exist(fullfile(paths{pathind}, 'flag.mat'), 'file')
            error('This folder has already been added')
        end
        [~, subfoldername] = fileparts(paths{pathind});
        fprintf('------------------------Adding Folder %g: %s------------------------\n', pathind, subfoldername)
       
        
        p = load(fullfile(paths{pathind}, inputfile));
        vars = fieldnames(p);
        inputs = p.(vars{1});
        temparameters = renameStructField(inputs, 'etarange', 'eta');

        %% Check if using integrated hctsa
        if isstruct(inputs.integrated_hctsa)
            no_hctsa = ~any(structfun(@(x) ~isempty(x), inputs.integrated_hctsa));
        else
            no_hctsa = isempty(inputs.integrated_hctsa);
        end     
        
        if no_hctsa
            [TS_DataMat, TimeSeries, Operations] = TS_LoadData(fullfile(paths{pathind}, datafile));
        else
            load(fullfile(paths{pathind}, datafile), 'TS_DataMat', 'Operations')
        end
        [~, opidxs] = sort(Operations.ID); % Sort Operations by ID
        Operations = Operations(opidxs, :);
        TS_DataMat = TS_DataMat(:, opidxs); % Sort datamat by moving columns
        
        if no_hctsa
            %[~, TSidxs] = sort(TimeSeries.ID);
            %TS_DataMat = TS_DataMat(TSidxs, :); % Sort datamat by moving rows;
            [TSids, TSidxs] = sort(TimeSeries.ID);
            TS_DataMat = TS_DataMat(TSidxs, :); % Sort datamat by moving rows, in case distributed_hctsa reordered them;
            % TS_DataMat rows should remain in the order common to the cp_range
            % (Which should be in increasing cp_range order for each set of
            % timeseries)
            % Check to see if hctsa removed some nan timeseries, and add these back in
            cpetas = TimeSeries.Name(TSidxs); % Sort to match datamat
            cpetas = [str2double(regexprep(cpetas, '|.*', '')), str2double(regexprep(cpetas, '.*|', ''))];
            expectedCpetas = cartesian_product(temparameters.cp_range, temparameters.eta);
            if length(cpetas) ~= size(expectedCpetas, 1)
                warning('It looks like some of the timeseries contained special values, which hctsa removed. Now adding them back into the data matrix')
                
                % Check if this combination of expected cp and eta is present
                badIDs = sum(~ismember(expectedCpetas, cpetas, 'rows'));
                % Found some, now where do they belong?
                % Can work out how many timeseries were supplied to
                % hctsa using the cp and eta range of inputs. Then,
                % assuming the timeseries IDs would be ordered:
                if badIDs
                    properTSids = (1:size(expectedCpetas, 1))';
                    while length(properTSids) ~= length(TSids)
                        badInd = find(~ismember(properTSids, TSids), 1); % Get one bad index
                        % The TSids shoudl have originally been
                        % 1:numtimeseries, so this badInd shoudl equal its
                        % properTSid
                        TSids = [TSids(1:badInd-1); badInd; TSids(badInd:end)];
                        TS_DataMat = [TS_DataMat(1:badInd-1, :); nan(1, size(TS_DataMat, 2)); TS_DataMat(badInd:end, :)]; % Insert a ana row, representing this nan timeseries, into the datamat
                        % This will continue until TSids matches properTSids
                    end
                    if any(properTSids ~= TSids)
                        error('Something went wrong; the timeseries indices are not correct')
                    end
                end
            end
            % Find the indices of any
        else
            warning('No time series are availiable. Trusting that you have not reordered the data matrix...')
        end

        
        if exist('m', 'var') && leaveflag
            flagid = nrows+1:nrows+length(inputs.etarange); % nrows loaded
            save(fullfile(paths{pathind}, 'flag.mat'), 'flagid')
        end

        savestruct = repmat(struct('TS_DataMat', [], 'Operations', Operations, ...
                'Correlation', [], 'Source', source, ...
                'Inputs', [], 'Date', date, 'Keywords', keywords, 'Correlation_Type', [], 'Correlation_Range', []), length(inputs.etarange), 1);

        for i = 1:length(inputs.etarange)
            %fprintf('------------------------%g%% complete, %gs elapsed------------------------\n', round(100*(i-1)./length(parameters.etarange)), round(toc))
            savestruct(i, 1).TS_DataMat = TS_DataMat(1+length(inputs.cp_range)*(i-1):length(inputs.cp_range)*i, :);
            temparameters.eta = inputs.etarange(i);
            savestruct(i, 1).Inputs = temparameters;
        end
        savestructcell{pathind} = savestruct;
    end
    
    if ~isempty(filepath) && ~exist(filepath, 'file')
        time_series_data = struct('TS_DataMat', {}, 'Operations', {}, 'Correlation', {}, 'Source', {}, 'Inputs', {}, 'Date', {}, 'Keywords', {}, 'Correlation_Type', {}, 'Correlation_Range', {});%, 'Feature_Value_Shift', {});
        nrows = 0;
        save(filepath, 'time_series_data', 'nrows', '-v7.3')
    end
    savestructcell = savestructcell(cellfun(@(x) ~isempty(x), savestructcell));
    savestruct = cell2mat(savestructcell);
    if ~isempty(filepath)
        m = load(filepath); 
        oldnrows = m.nrows;
        nrows = oldnrows + size(savestruct, 1);

        if isempty(m.time_series_data)
            m.time_series_data = savestruct;
        else
            m.time_series_data(oldnrows+1:nrows, 1) = savestruct; % Need faster way to modify time_series_data
        end
        m.nrows = nrows;
        fprintf('------------------------Finished Loading, Saving Results------------------------\n')
        save(filepath, '-struct', 'm', '-v7.3')%, '-nocompression')
        savestruct = [];
    end
    fprintf('Done!\n')
    %fprintf('------------------------100%% complete, %gs elapsed------------------------\n', round(toc))
end
